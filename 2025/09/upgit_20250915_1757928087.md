
## 概念梳理
- 主播
- 厅
- 公会
- 经纪人
![[Pasted image 20240927003050.png]]


**公会是人的组织，厅是开播的形式（类似学校、学生和班级）**


## 数据存储


表名对应的业务

| 表名              | 业务          | 交互对象                   |
| --------------- | ----------- | ---------------------- |
| user            | 用户          |                        |
| sign_anchor     | 主播          | 厅、公会                   |
| principal       | 经纪人         | 公会、经纪人分组               |
| guild           | 公会          | 主播                     |
| hall            | 厅           | 主播                     |
| task            | 任务          | user_account           |
| user_account    | 用户账号（有余额信息） | withdraw               |
| withdraw        | 提现          | user_account           |
| guild_level     | 公会等级        | guild                  |
| pre_sign_anchor | 预签约审核（流程数据） | sign_anchor、guild、hall |

![[Diagram 1.png]]


```python

class PrincipalType(StrEnum):
	GUILD = "guild"
	AGENT = "agent"
	GUILD_AGENT = "guild_agent"

@dataclass
class Principal:
	"lgid": Lgid
	"user_id": UserID
	"agent_lgid": Lgid
	"parent_lgid": Lgid
	"parent_user_id": UserID
	
	"add_date": Timestamp
	"status": int
	"group": PrincipalType
	"manage_type": PrincipalType
	
	"name": str
	"nickname": str
	"locale": str
	"phone": str
	"wx_no": str
```

```python

@dataclass
class SignAnchor:
    "user_id": UserID
    "user_type": int
    "anchor_type": int

    # 基本信息
    "nickname": str
    "phone": str
    "locale": str
    "status": int

    # 经纪人信息
    "principal": str
    "guild_id": GuildID
    "principal_id": PrincipalID
    "agent_lgid": Lgid
    "top_agent": Lgid

	# 时间
    "add_date": Timestamp
    "update_date": Timestamp
    "sign_date": Timestamp
    "cancel_date": Timestamp
    "pass_date": Timestamp

    # 身份证
    "cert_no": str
    "cert_name": str
    "id_card": str

    # 合同待遇、底薪要求
    "contract": str
    "anchor_commission_rate": float
    "hall_member_commission_rate": float

    "pay_type": list[int]

    "single_target": int
    "target_time": int
    "scale": float
    "un_scale": float
    "base_salary": int
    "month_target": int
    "target_beans": int
    "exchange_type": int
    "anchor_level": str
    "sign_level": str
    
    # 状态
    "confirm": str
    "balance_at_sign": int
    "bank_status": int

    # 其他 
    "is_asyn": int
    "alimsg": str
    "paypalmsg": str
    "payoneermsg": str
    
    "authorized": int
    "youzan": str
    "sign_comment": str
    "in_rule": int
    "jihua_user_id": str
    "main_lgid": int | str
```


```python

class LiveHallStatus(IntEnum):
    ACTIVE = 1
    TERMINATED = 2


class LiveHallType(IntEnum):
    AUDIO = 1
    VIDEO = 2


@dataclass
class LiveHall:
    "status": LiveHallStatus
    "hall_type": LiveHallType

    # 关系
    "anchor_id": UserID
    "hall_owner_id": UserID
    "guild_id": GuildID
    "agent_lgid": Lgid

    # 时间
    "add_date": Timestamp
    "cancel_time": 0 | Timestamp
    "bind_time": Timestamp
    "first_bind_time": Timestamp
    
    # 简介
    "status_label": 1
    "principal": str
    "hall_name": str
    "hall_simple_name": str

```

```python

class GuildType(IntEnum):
    LESPARK = 0
    THIRD = 1


class GuildStatus(IntEnum):
    ACTIVE = 0
    DELETED = 1


@dataclass
class Guild:
    # 基础信息
    "name": str
    "status": GuildStatus
    "guild_type": GuildType

    "user_id": UserID
    "principal_id": PrincipalID
    
    # 时间
    "add_date": Timestamp
    "update_date": Timestamp
    
    # 冗余信息
    "wx_no": str
    "phone": str
    "nickname": str
    "locale": str

```


数据的设计是没问题的

## 新签约流程预期和现存问题

> 既然数据设计没问题，为什么现在签约流程还经常反馈问题？

现存问题：
- 经纪人数据组长看不到
- 缺少准确的签约历史记录
- 主播、厅员、公会的经纪人错乱或不一致
- 预签约过一审二审结果和表现不一致，如创建厅员一审二审通过后，提示成功不一定能创建出来厅员
- 厅主过期了厅员的数据还在
- 存在一些 UB (Undefined Behaviour: 未定义行为)，这些会导致不明确的结果
- .......


忽略问题，我们需要一个怎样的签约系统？
- 签约操作简单、唯一、需要的功能要有（产品改进）
- 数据准确、方便查询（技术改进）
- 提示和结果一致（技术改进）
- 可追溯（技术改进）

## 状态机

那么技术上，对于数据的准确和一致性、提示和结果的一致性，要怎么优化？

原签约流程是哪里没做好准确和一致性：
- 经纪人内部的上下级关系，是缺失的，是通过人工添加的 parent_lgid 等字段表示的；
- 审核的流程、数据变更是混在一起的；比如绑厅员
- 数据的变更是零散的，数据的获取是各种各样的
- 同一输入不一定有同一输出

### 统一数据操作

各角色操作用例

![[3EC5618D-F0AB-42E0-989D-0735DBD2BBE0.png]]


以厅操作示例：把所有的数据和操作打包在一起，要查要改要操作什么都通过 LiveHallMixin 调用

![[未命名绘图.drawio.png]]


### 统一审核状态变更流程，切割审核流转和申请业务

这里我们会使用状态机的模型，来处理状态流转

![[Pasted image 20240927120941.png]]

状态机能解决什么问题：
- 规定了状态流转的顺序，并且是确定的，只能按照图里的箭头流转
  ==解决了我们前面数据变更零散的问题，并且没有 UB，所有的行为都是明确的==
- 在状态机里，切割了审核和实际的业务操作
  ==审核成功后，最后由 handle_apply 去处理各种申请：厅员、公会长、主播等，前面都只处理审核状态的变化==
- 更强的检查环节，保障数据的准确性
  ==在每个流程（也就是箭头），可以方便的添加各种检查，确保输入参数不变能得到固定的输出==
  
  举例 commit_apply（提交审核） 环节，可以在这个流程的开始、进行、结束后三个节点检查
  1. 流程开始：提交审核前，检查参数是否合法：提交的主播是否实名、提交的主播是否归属经纪人、提交的厅员申请中厅员厅主是否归属不同经纪人、绑厅是否选择了直签个播公会
  2. 进行中：检查通过了，我们可以进行正式的数据变更
  3. 结束后：二次检查刚才进行的数据变更，是否符合我们的业务逻辑，字段中的数据是否一致；还可以发送钉钉消息


### 加强数据的原子性、一致性（事务或撤销）

有些业务，如更换公会的经纪人，从A变成B，会同时变更多个表
- guild
- principal
- sign_anchor

在之前的处理逻辑是这样的：
1. 先更换公会 guild 的经纪人
2. 更新公会下，所有公会主播的经纪人
3. 更新公会下，所有公会主播的厅数据的经纪人
4. 更新预签约审核数据，所有公会主播的签约归属经纪人

这些流程是各自独立的，如果在中途某一个步骤出错了，那么就会得到混乱的数据；
如第 3 步出错了，就会看到：
- 主播管理页面，该公会名下主播的经纪人已经变了
- 厅管理页面，看到这些主播的经纪人还是原样，此时 经纪人B 操作解绑厅或一些厅员变动，就会失败，而原经纪人A还可以继续操作
又或者是第3步，中途出错了，厅主改成功归属了，厅员还没有

所以这里通过事务或者创建后的检查，去保证一致性：
- 能用事务的，准备好所有的数据变更，然后提交到数据库
- 如果是已经拆分成不同的类里面，调用对应的方法，方法里面使用事务，检查调用的流程返回的结果；比如创建厅员要先创建主播，然后绑定厅员，需要分别调用到

```python


创建主播结果 = SignAnchorMixin.创建主播()
绑厅员结果 = LiveHallMixin.绑定厅员()

检查 （创建主播结果 和 绑厅员结果 是否都成功）

如果不成功：
    SignAnchorMixin.取消创建主播()
    LiveHallMixin.取消绑定厅员()
    
```

**通过事务或者是 undo 撤销的方式，我们保证一个业务申请对应的所有表的数据，是同时存在或者同时不存在的；**

**如果成功，状态机才会流转到下一个状态，如果失败，则会维持原状态；带来的好处是，我只需要解决失败的报错原因，后续可以由经纪人继续走流程来完成签约，而不需要人工修补数据**

**并且，在后台界面上，反馈的结果是数据检查最终的结果；
即如果消息提示成功，数据一定是成功的，就能够避免后续的操作；**


### 双重保险：流程外的检查

在流程之外，我们可以用定时的脚本，去扫描预签约的数据，对每条数据的状态和申请内容，进行当前时刻的检查

并且由于我们定义了状态机，状态机里面会检查每个预签约的结果，所以可以直接复用这个检查，去检查存量的数据和增量的数据
